#include "urdf_to_osim/urdf_to_osim.h"

#include <wordexp.h>
#include <string>
#include <regex>

#include <ros/ros.h>
#include <kdl/kdl.hpp>
#include <kdl_parser/kdl_parser.hpp>
#include <urdf/model.h>
#include <boost/filesystem.hpp>
#include <OpenSim/OpenSim.h>

auto
get_link_number(const std::string& str_link)
{
	// https://yunmingzhang.wordpress.com/2018/11/13/regular-expressions-in-c-and-extract-first-integer-in-string/

	if (auto n = str_link.find_first_of("0123456789"); n != std::string::npos)
	{
		std::size_t const m = str_link.find_first_not_of("0123456789", n);
		return stoi(str_link.substr(n, m != std::string::npos ? m-n : m));
	}

	return -1;
}


bool
urdf_to_osim(const std::string& path_to_urdf, const std::string& dir_osim_output)
{
	// ----------------------------------------------------------------------------------------------

	// > directories

	auto dir_urdf           = boost::filesystem::path(path_to_urdf).parent_path().string();
	auto dir_mesh_visual    = dir_urdf + "/../meshes/visual";
	auto dir_mesh_collision = dir_urdf + "/../meshes/collision";

	// check that files and directories exist

	if (not boost::filesystem::exists(path_to_urdf))
	{
		ROS_ERROR("URDF file could not be located, expected: '%s'.", path_to_urdf.c_str());
		return false;
	}

	if (not boost::filesystem::exists(dir_mesh_visual))
	{
		ROS_ERROR("Could not locate visual meshes directory, expected: '%s'.", dir_mesh_visual.c_str());
		return false;
	}

	if (not boost::filesystem::exists(dir_mesh_collision))
	{
		ROS_ERROR("Could not locate collision meshes directory, expected: '%s'.", dir_mesh_collision.c_str());
		return false;
	}

	if (not boost::filesystem::exists(dir_osim_output))
	{
		ROS_WARN("Creating OSIM output directory: '%s'.", dir_osim_output.c_str());
		boost::filesystem::create_directories(dir_osim_output);
	}

	// info
	
	ROS_INFO("URDF filepath: '%s'.", path_to_urdf.c_str());
	ROS_INFO("OSIM output directory: '%s'.", dir_osim_output.c_str());
	std::cout << "\n";

	// ----------------------------------------------------------------------------------------------

	// > load URDF model

	urdf::Model urdf_model;
	if (not urdf_model.initFile(path_to_urdf)){
		ROS_ERROR("Failed to parse URDF file.");
		return false;
	}
	
	// > create KDL tree from URDF model

	KDL::Tree kdl_tree;
	// if (not kdl_parser::treeFromFile(path_to_urdf, kdl_tree))
	if (not kdl_parser::treeFromUrdfModel(urdf_model, kdl_tree))
	{
		ROS_ERROR("Failed to construct KDL tree.");
		return false;
	}

	ROS_INFO("Loaded URDF model [%s] and constructed KDL tree.", urdf_model.getName().c_str());

	// ----------------------------------------------------------------------------------------------

	// > OSIM model creation
	// convert KDL tree to OSIM model

	OpenSim::Model osim_model;
	osim_model.setAuthors("Autogenerated using urdf_to_osim");
	osim_model.setName(urdf_model.getName());

	for (const auto& [link_name, link] : urdf_model.links_)
	{
		std::cout << "link->name: " << link_name << "\n";
		std::cout << link->name << std::endl;

		if (link->visual->geometry)
			std::cout << ((urdf::Mesh*)link->visual->geometry.get())->filename << std::endl;

		if (link->inertial)
			std::cout << link->inertial->mass << std::endl;
	}

	// create ground/world link
	;

	// logging
	constexpr auto COLW     = 14;
	constexpr auto COLALIGN = std::left;
	std::apply([&](auto &&... args){ ((std::cout << COLALIGN << std::setw(COLW) << args), ...); std::cout << "\n"; }, std::tuple{ "link_name", "link_nr", "joint_nr", "link_mass [kg]" });
	std::cout << std::string(COLW*4, '-') << "\n";

	// iterate segments of KDL tree
	for (const auto [link_name, element] : kdl_tree.getSegments())
	{
		if (link_name == "world")
			continue;
		
		const auto link_number  = get_link_number(link_name);
		const auto joint_number = element.q_nr;
		const auto link_mass    = element.segment.getInertia().getMass();

		// log info
		std::apply([&](auto &&... args){ ((std::cout << COLALIGN << std::setw(COLW) << std::setprecision(4) << args), ...); std::cout << "\n"; }, std::tuple{link_name, link_number, joint_number, link_mass });

	}

	// ----------------------------------------------------------------------------------------------

	// export 

	return true;
}

// ----------------------------------------------------------------------------------------------

int
main(int argc, char** argv)
{

	// verfify that correct number of arguments passed
	if (argc != 2 && argc !=3)
	{
		std::cerr << "Usage:   urdf_to_osim input_file [absolute_output_dir]" << std::endl;
		std::cerr << "Example: urdf_to_osim panda.urdf ~/path/to/output/dir" << std::endl;
		return 0;
	}

	// get parameters
	auto path_to_urdf    = boost::filesystem::current_path().string() + "/" + argv[1];
	auto dir_osim_output = argv[2] ? std::string(argv[2]) : boost::filesystem::current_path().string() + "/osim-model";
	
	// expand output directory
	wordexp_t exp_result;
	wordexp(dir_osim_output.c_str(), &exp_result, 0);
	dir_osim_output = exp_result.we_wordv[0];

	// create OSIM model
	auto osim_model = urdf_to_osim(path_to_urdf, dir_osim_output);

	// export OSIM model to specified path
	;

	return 0;
}